# Поля выбора

`Selectable` - это замена стандартным селект-боксам способная содержать любой HTML контент
в полях опций, а так же имеющая более управляемый внешний вид.

<%= partial '/ui/head', :locals => {:name => 'selectable'} %>

<%= anchors_index %>


## Список возможностей, :features

Наши поля выбора имеют следующие возможности

* Работает как с множественными, так и с единичными выборами
* Может работать как самостоятельный виджет
* Может быть подключен к полю ввода и работать в составе форм
* Все включено в один небольшой (~ 6k) файл, включая базовые стили
* Простое и гибкое использование с многими опциями


## Базовое использование, :usage

После того, как вы подключите один из вышеперечисленных файлов на вашу страницу,
у вас будет выбор: использовать класс `Selectable` для того чтобы генерировать виджеты
программно из кода JavaScript

    new Selectable({
      options: ['раз', 'два', 'три', 'четыре', 'пять']
    }).insertTo('the-container');

Или же вы можете подготовить обычный элемент HTML списка и создать поле выбора из него

    <ul id="my-selectable">
      <li>Раз</li>
      <li>Два</li>
      <li>Три</li>
      <li>Четыре</li>
      <li>Пять</li>
    </ul>

    new Selectable('my-selectable', {
      selected: 2,
      disabled: [1,3]
    });

А так же вы можете назначить на ваш элемент списка css-класс `right-selectable` и
наш скрипт найдет его и автоматически создаст виджет поля выбора.

    <ol class="right-selectable">
      <li>One</li>
      <li>Two</li>
    </ol>

Да, вы можете использовать любой тип списка `UL` или `OL`, а так же использовать
атрибуты опций в стиле HTML5 `data-selectable-options`, как и с любым другим виджетом
RightJS

И еще вы можете автоматически конвертировать обычные селект-боксы, в поля выбора,
просто назначив им css-класс `right-selectable`. Скрипт автоматически найдет их,
сгенерирует и вставит замену, а так же скроет оригинальные элементы. В этом случае,
форма которой принадлежит оригинальный список не заметит никаких изменений.

    <select name="boo" class="right-selectable">
      <option value="1"><b>Р</b>аз</option>
      <option value="2"><b>Д</b>ва</option>
      ....
    </select>



## Различные варианты, :variants

По умолчанию, данный скрипт будет создавать поля множественного выбора, но вы так же
можете создавать поля с одним выбором, указав дополнительный css-класс `right-selectable-single`
или опцию `multiple: false` любым доступным способом.

    <ul class="right-selectable right-selectable-single">
      ....
    </ul>

    <ul class="right-selectable" data-selectable-options="{multiple:false}">
      ...
    </ul>

Вы так же можете создавать поля выбора с группами опций. Для этой цели используйте стандартную
конструкцию из тегов списка с описаниями `dl/dt/dd`

    <dl class="right-selectable">
      <dt>Первая группа</dt>
      <dd>
        <ul>
          <li>Раз</li>
          <li>Два</li>
        </ul>
      </dd>
      <dt>Вторая группа</dt>
      <dd>
        <ul>
          <li>Три</li>
          <li>Четыре</li>
        </ul>
      </dd>
    </dl>

Вы можете использовать списки с группами в обоих случаях, в полях с множественным и с единичным выборами.


## Работа в составе формы, :assign

Поля выбора могут быть легко назначены на работу в паре с элементами ввода форм, например скрытыми полями.
Для этой цели можно использовать метод `assignTo()` или опцию `update`, как в следующем примере

    <form ...>
      <input id="the-value" type="hidden" />
  
      // программно
      new Selectable({...}).assignTo('the-value');
  
      // автоматически
      <ul class="right-selectable"
        data-selectable-options="{update: 'the-value'}">
        ....
      </ul>
  
    </form>


__ВНИМАНИЕ:__ связь между виджетом и полем ввода, работает в обоих направлениях.
Когда пользователь делает выбор в поле выбора, скрипт автоматически меняет значение
в назначенном поле ввода, и наоборот.

Так же существует несколько способов, какие именно значения будут отправлены в
совместно используемое поле ввода.

Если вы использовали, обычный плоский список опций или простой список из `LI` тэгов,
тогда скрипт будет использовать в качестве значений индекс выбранной опции в списке

    var selectable = new Selectable({
      options: ['one', 'two', 'three'],
      select: [0,1]
    });

    // или HTML
    <ul>
      <li>one</li>
      <li>two</li>
      <li>three</li>
    </ul>

    selectable.getValue(); // -> [0, 1]


Но если вы использовали хэш ключ-значение в качестве опций, или в случае HTML 
списка, использовали тэги `LI` с атрибутами `id`, то ключи хэша и/или 
атрибуты `id` будут использованы в качестве значений

    var selectable = new Selectable({
      options: {
        one: 'First',
        two: 'Second',
        three: 'Third'
      },
      selected: [0,1]
    });

    // эквивалентный HTML
    <ul>
      <li id="one">First</li>
      <li id="two">Second</li>
      <li id="three">Third</li>
    </ul>

    selectable.getValue(); // -> ['one', 'two']

Так же существует еще одна возможность. Если ваши ключи имеют вид последовательности
с целыми значениями, например `thing-1`, `thing-2`, `thing-3`, то вы можете указать
опцию `parseIds: true` и тогда скрипт будет автоматически выделять целочисленную часть
ключа и использовать ее в качестве значений

    var selectable = new Selectable({
      options: {
        'thing-1': 'First',
        'thing-2': 'Second',
        'thing-3': 'Third'
      },
      selected: [0,1],
      parseIds: true
    });

    // эквивалентный HTML
    <ul>
      <li id="thing-1">First</li>
      <li id="thing-2">Second</li>
      <li id="thing-3">Third</li>
    </ul>

    selectable.getValue(); // -> [1, 2]


## Список опций, :options

Вы можете использовать следующие опции любым доступным способом. С конструктором класса
`Selectable`, в виде JSON данных в атрибуте `data-selectable-options` или глобально
в переменной `Selectable.Options`

Имя        | Умолчание | Описание
-----------|-----------|--------------------------------------------------------------------
options    | null      | хэш ключ-значение или массив опций
selected   | null      | список индексов опций выбранных по умолчанию
disabled   | null      | список индексов опций заблокированных по умолчанию
multiple   | true      | флаг, если это должно быть поле со множественным или единичным выбором
fxName     | 'slide'   | эффект для выпадающего списка (null, 'slide', 'fade')
fxDuration | 'short'   | длительность эффекта для выпадающего списка
update     | null      | ссылка на назначенный элемент
parseIds   | false     | если поставить `true` будет автоматически выделять целое значение из опций
refresh    | true      | флаг, если скрипт должен автоматически обновлять список


## Список событий, :events

Вы можете использовать следующий список поддерживаемых событий с объектами полей выбора

Имя      | Описание
---------|---------------------------------------------------
change   | значение было изменено
select   | позиция была помечена выделенной
unselect | позиция потеряла маркер выделения
disable  | позиция была заблокирована
enable   | позиция была разблокирована
hover    | пользователь поместил курсор над позицией
leave    | пользователь убрал курсор с позиции
show     | выпадающий список был показан
hide     | выпадающий список был закрыт

Все слушатели событий относящихся к конкретным позициям, а именно: `select`, `unselect`, `disable`,
`enable`, `hover` и `leave`, будут получать три аргумента, элемент позиции (LI элемент), индекс позиции
в списке и ссылку на сам объект поля выбора.

Слушатели события `change` получат два аргумента, текущее значение и ссылку на объект поля выбора.

И на конец слушатели событий `show` и `hide` получат только ссылку на объект поля выбора.


## API-документация, :api

Объекты класса `Selectable` предоставляют доступ к следующим открытым методам

Имя               | Описание
------------------|----------------------------------------------------------
initialize(\[element,\] Object options) | базовый конструктор
destroy()         | деструктор
setValue(value)   | устанавливает текущее значение
getValue()        | возвращает текущее значение
select(item)      | выделяет указанные позиции
unselect(item)    | снимает выделение с указанных позиций
selected(item)    | проверяет если указанные позиции выделены
disable(item)     | блокирует указанные позиции
enable(item)      | разблокирует указанные позиции
disabled(item)    | проверяет если указанные позиции заблокированы
insertTo(element\[, position\]) | вставляет виджет в указанный элемент
assignTo(element) | назначает другой элемент работать в паре с полем выбора
refresh()         | обновляет список опций


__ВНИМАНИЕ:__ методы относящиеся к работе с отдельными позициями, такие как например `select`, `unselect`,
и т.п., могут получать несколько типов аргументов. Это могут быть числовые индексы позиций в списке, это
могут быть ключи/ID-атрибуты позиций, или это могут быть элементы списка (LI) сами по себе.
Вы так же можете посылать как массивы так и отдельные позиции, работает в обоих случаях.

Еще можно вызывать эти методы _без_ аргументов. В этом случае скрипт будет считать что вы желаете
обработать _все_ позиции в списке.


## Настройки стилей, :styles

Структура элементов, будет в целом оставлена нетронутой, такой, как она описана в разделе
[базового использования](#usage). Скрипт так же будет назначать css-классы
`right-selectable-selected` и `right-selectable-disabled`, соответственно для выделенных
и заблокированных позиций.

    <ul class="right-selectable">
      <li class="right-selectable-selected">Selected item</li>
      <li class="right-selectable-disabled">Disabled item</li>
      <li>Another item</li>
    </ul>

Для полей с единичным выбором, скрипт добавит css-класс `right-selectable-single` и вставит
структуру следующего вида непосредственно перед списком.

    <div class="right-selectable-container">
      <div class="right-selectable-handle">&bull;</div>
      <ul>
        <li>Selected item</li>
      </ul>
    </div>

Что будет работать видимым блоком селект-бокса. Элемент `LI` будет клонироваться от
выбранного пользователем элемента списка.
