# Вызов по имени

_Вызов по имени_ это одна из основополагающих возможностей в RigthJS и работает
во многих местах по всему фреймворку и плагинам.

Идея очень проста. Данная возможность схожа с методом массивов `invoke` в некоторых
языках программирования

    ['foo', 'boo', 'moo'].invoke('replace', 'oo', 'aa');
    
    // -> ['faa', 'baa', 'maa']

Вы просто указываете имя метода и несколько необходимых аргументов. Далее метод
`invoke` пройдет по всем элементам массива и вызовет на каждом из них указанный
метод с указанными аргументами.

Но вместо того, чтобы создавать подобные дополнительные методы, RightJS расширяет
данную идею и дает вам возможность использовать ее глобально, со всеми стандартными
методами коллекций, а так же при обработке событий.

Скажем, в стандартном подходе вы могли бы удалить все тэги из списка строк, вот таким образом

    strings.map(function(string) {
      return string.stripTags();
    });

В RightJS вы можете сделать тоже самое просто указав метод по имени

    strings.map('stripTags');

RightJS единообразно работает как с методами, так и с атрибутами элементов
массивов. Несколько примеров

    // несколько примеров обработки списка строк
    var lowercased = strings.map('toLowerCase');
    var uppercased = strings.map('toUpperCase');
    var trimmed    = strings.map('trim');
    var blanks     = strings.filter('blank');
    var replaced   = strings.map('replace', 'some', 'another');
    
    // собираем все ID элементов
    var ids = elements.map('id');
    
    // блокируем все элементы списка
    elements.each('disable');
    
    // добавляем класс 'marked' для каждого элемента
    elements.each('addClass', 'marked');
    
    // указываем обработчик события по имени
    element.onClick('toggleClass', 'marked');
    
    // подключаем слушателя события для каждого элемента
    elements.each('onClick', 'toggleClass', 'marked');
    

## Зачем это делать?, :why

Если вы все еще не поняли идеи, попробуйте прочитать кусок кода в предыдущем
примере еще раз. Просто как обычный текст. Возможность указывать обработчик
по имени, позволяет писать естественный, удобочитаемый код легко понятный
другим разработчикам.

В практике JavaScript программирования существует множество случаев, когда
все что вам нужно, это вызывать _уже существующий_ метод каждого элемента.
Отказавшись от использования функций посредников в подобных случаях вы не
просто делаете код более читабельным, вы так же можете значительно сократить
его размер и как следствие количество потенциальных опечаток и багов в нем.


## А что с производительностью?, :overhead

Практически нет разницы между вызовом реальной функции или указанием ее
по имени. И на самом деле, если в массиве больше чем пара элементов, такой
подход работает быстрее, чем если бы вы использовали функцию посредник, возможно
еще и поместив ее в дополнительную функцию создающую правильный контекст.
Т.к. он не использует дополнительных функций и вызывает все методы напрямую.

В результате, в большинстве случаев рутинных операций такие вызовы работают
быстрее. Загляните за примером на [страницу бенчмарков](/benchmarks) и вы все увидите.
