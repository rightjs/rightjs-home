# Ajax фото галлерея

__ВНИМАНИЕ__: данная статья имеет своей целью описать внутренние процессы и разные подходы
к созданию ajax фото галлереи. Если вам просто необходимо что-то, что работает под RubyOnRails,
попробуйте официальный Rails плагин для RightJS [right-rails](http://github.com/MadRabbit/right-rails),
в нем все уже реализовано и убрано под цивилизованный интерфейс.



## Исходный код примера, :source

В данной статье мы будем разрабатывать полностью все приложение, но не все его части будут опубликованы.
Вы можете скачать полную версию всех исходных кодов данного примера из github репозитория.

<http://github.com/MadRabbit/right-gallery>

`git clone git://github.com/MadRabbit/right-gallery.git`

В целом это простое приложение ruby-on-rails. Уверен вы знаете как его запустить и поиграться.



## Стратегия, :strategy

Существует несколько возможных путей реализации ajax приложения. Некоторые проще, некоторые сложнее,
мы выберем достаточно редкий, но интересный смешанный подход. Мы начнем работу со стандартного
CRUD контроллера и базовой функциональности, и затем создадим ненавязчивую (unobtrusive) JavaScript
обертку предоставляющую ajax функциональность.

Цель данного подхода, создать прозрачный ajax модуль, который не будет ломать оригинальную
функциональность, так что пользователь всегда сможет открыть все ссылки в новом окне или дать ссылку
другому пользователю.

Мы так же собираемся использовать все оригинальные темплейты, и создать очень простой JavaScript код.

При разработке мы будем использовать фреймворк ruby-on-rails, просто потому, что большинство людей
работающих с динамическими языками, в той или иной мере знакомы с ним или хотя бы с используемой
терминологией.


## Подготовительный этап, :preparations

Может существовать несколько способов организовать шаблоны и код в приложениях на ruby-on-rails, но
мы постараемся придерживаться стандартов. Мы сгенерируем стандартный CRUD контроллер встроенным
в Rails скаффолд-генератором.

Затем мы извлечем частичный темплейт картинки из шаблона `index`, так чтобы мы могли использовать
его для генерации отдельно взятых картинок при ajax запросах. Шаблоны `index` и `_picture` должны
выглядеть примерно следующим образом

    // index.html.erb
    <h1>Listing pictures</h1>

    <div id="pictures">
      &lt;%= render @pictures %>
    </div>


    // _picture.html.erb
    &lt;% div_for picture do %>
      &lt;%= link_to image_tag(picture.thmb_url), picture.full_url %>
    
      &lt;%= link_to 'Edit', edit_picture_path(picture) %>
      &lt;%= link_to 'Destroy', picture, :confirm => 'Are you sure?', :method => :delete %>
    &lt;% end %>


Мы так же извлечем частичный шаблон формы `_form` из страниц `new` и `edit`, так что бы мы могли
использовать формы отдельно от всего прочего.

    // new.html.erb
    <h1>New picture</h1>

    &lt;%= render 'form' %>


    // edit.html.erb
    <h1>Edit picture</h1>

    &lt;%= render 'form' %>


    // _form.html.erb
    &lt;% form_for(@picture, :html => {:multipart => :true}) do |f| %>
      &lt;%= f.error_messages %>
      // .....
      <p class="buttons">
        &lt;%= f.submit  f.object.new_record? ? 'Create' : 'Update' %>
      </p>
    &lt;% end %>

Это вобщем-то все с подготовительной частью, давайте теперь перейдем к чему-нибудь более интересному


## Удаление картинок, :deleting

Чтобы не бросаться сразу с головой в омут, начнем с простой операции по удалению картинок.

Т.к. мы решили идти unobtrusive путем, мы собираемся перехватить с помощью нашего скрипта клик на
ссылках `delete`, и подключить наш собственный обработчик который будет удалять картинки через
ajax запросы. При таком подходе, если мы что-либо сломаем в нашем скрипте, оригинальная функциональность
все еще будет доступна и прикроет нам тылы.

Для начала мы добавим css-класс `delete` для ссылок на удаление в шаблоне `_picture`,
так чтобы мы могли найти их из нашего скрипта

    // _picture.html.erb
    &lt; div_for picture do %>
      ......
      &lt;%= link_to 'Destroy', picture, :class => :delete //...
    &lt;% end %>

Добавление подобных классов, хорошая практика в любом случае, т.к. позволяет
программно идентифицировать ссылки, и возможно например покрасить их другим цветом
из css, добавить иконки и т.п.

Грабим ссылки

    function hijack_links() {
      $$('#pictures a.delete').each(function(link) {
        link.onclick = function(event) {
          event.stop();
      
          if (confirm("Подумал?")) {
            Xhr.load(this.href+".js", { method: 'delete' });
          }
        };
      });
    }
    hijack_links();

Мы помещаем код в функцию, так чтобы мы могли вызвать его вновь, когда на странице появятся
новые картинки после загрузки через ajax.

Далее, т.к. мы добавили формат `.js` к адресу в нашем скрипте, необходимо добавить обработчик
этого формата в метод `destroy` в соответствующем контроллере ruby-on-rails.

    def destroy
      .....
      respond_to do |format|
        ....
        format.js
      end
    end

Нам так же потребуется шаблон с именем `destroy.js.erb` который будет генерировать JavaScript
вызов на удаление картирки

    // destroy.js.erb
    remove_picture(&lt;%= @picture.id %>);


    // index.html.erb
    function remove_picture(id) {
      $('picture_'+id).remove();
    }

Мы могли бы просто написать что-нибудь вроде `$('picture_&lt;%= @picture.id %>').remove()` 
в шаблоне, но всегда лучше разделять вызовы и саму функциональность и работать через некий
интерфейс, так чтобы код внутри можно было усовершенствовать позже не трогая другие шаблоны.

Двигаемся дальше


## Загрузка файлов, :uploading

Т.к. это ajax фото галлерея, то мы естественно хотели бы иметь некую скрытую форму для
немедленной загрузки картинок, непосредственно из списка. Для этой цели мы просто
создаем пустую переменную `@picture` и рендерим заранее выделенный частичный шаблон `_form`
сразу под ссылкой `'New picture'` в шаблоне `index`. И в конце концов добавляем обработчик события
`onclick` который будет показывать/скрывать нашу форму

    // index.html.erb
    // .....
    &lt;%= link_to 'New picture', new_picture_path,
      :onclick => "$('new-form-container').toggle('slide'); return false;" %>

    <div id="new-form-container">
      &lt;% @picture = Picture.new %>
      &lt;%= render 'form' %>
    </div>

В результате, если пользователь просто кликнет на ссылке, он увидит плавно появляющуюся/исчезающую
форму, но при этом все еще сможет использовать правый клик и открыть страницу создания новой
картинки в новом окне обычным способом.

Далее ниже, мы добавим еще одну JavaScript функцию которая будет конвертировать нашу форму, 
в форму для удаленной отправки. По стандарту форма для новых картинок будет иметь ID
`new_picture`, так что мы может легко это использовать

    function remotize_form(id) {
      $(id).remotize().enable().action += '.js';
    };
    remotize_form('new_picture');

Мы снова создали отдельную функцию, и снова по той же причине. Для того чтобы можно было
конвертировать другие формы (для редактирования) позже. И т.к. в RightJS все мутирующие
методы взвращают назад ссылку на сам объект, мы может написать интересную строчку кода,
как эта `form.remotize().enable().action`.

Далее, т.к. мы изменили формат в свойстве `action` формы, мы так же должны добавить его
обработчик в контроллере нашего приложения

    // PicturesController
    def create
      // ....
      respond_to do |format|
        // ....
        format.js
      end
    end

И последнее, мы должны создать файл шаблона `create.js.erb`, который будет генерировать
JavaScript код ответа на загрузки картинок и делать изменения на странице.

В шаблоне мы проверяем если картинка была сохранена, если все прошло успешно
генерируем вызов `insert_picture` с куском HTML из частичного шаблона `_picture`. И в конце
мы генерируем новую форму. Нам нужна эта новая форма в любом случае. Если сохранение
прошло успешно, нам понадобится чистая форма, а если были ошибки, то эта форма будет содержать
их текст и пометки на полях.

    &lt;% unless @picture.new_record? %>
      insert_picture("&lt;%= escape_javascript(render(@picture)) %>");
  
      &lt;% @picture = Picture.new # resetting the instance to have a clean form %>
    &lt;% end %>

    replace_form('new_form', "&lt;%= escape_javascript(render('form')) %>");

И еще раз мы создаем две новые маленькие функции JavaScript в нашем основном шаблоне `index`.
Первая из них вставляет исходник новой картинки на место, а вторая заменяет нашу форму
новым содержанием.

    function insert_picture(source) {
      $('pictures').insert(source);
      hijack_links();  // find and process the new links
    };

    function replace_form(id, source) {
      $(id).replace(source);
      remotize_form(id);
    };

Все это выглядит достаточно просто.



## К сожалению это не будет работать, :wont

Штука в том, что вы не можете отправлять файлы через обычные `XmltHTTPRequest` запросы,
и когда вы посылаете ajax формы с файлами, RightJS генерирует скрытый элемент IFrame и
отправляет форму через него. Но это не сама проблема.

Проблема в том, что мы используем формат `.js`,и когда iframe элемент получает
назад данные с типом контента не _html_, заботливые браузеры семейства IE предлагают
своим пользователям сохранить их содержимое на диск. А мы точно не хотим пугать
женщин и иностранцев подобными предложениями.

К счастью выход прост. Все что нам нужно, это создать новый простой лайаут

    // app/view/layouts/iframed.html.erb
    <html>
      <head>
        <script type="text/javascript">
        // <![CDATA[
          with (self.parent) {
            &lt;%= yield %>
          }
        // ]]>
        </script>
      </head>
    </html>

и еще немного изменить `format.js` вызов в контроллере, вот так

    def create
      ....
      format.js { render :layout => 'iframed', :content_type => 'text/html' }
    end

Идея проста. Во-первых мы оборачиваем наш скрипт ответа в HTML ответ, где он будет
выполнен по загрузке в контексте родительского окна, так как буд-то это был обычный Xhr
запрос с обычным JavaScript ответом.

Причина, почему нужно делать это таким образом, так же очень проста. Она позволяет
содержать шаблоны генерирующие JavaScript ответы в единообразном виде, не задумываясь
о том каким способом ответы потом доставляются назад в браузер. А так же он позволяет
использовать новый лайаут с другими контроллерами и операциями.

Это в общем-то весь трюк. После этого загрузка будет работать как и задумывалась.



## Редактирование картинок, :editing

Закончим мы на создании функциональности по редактированию картинок. Теперь, когда
мы знаем как все работает, не будет никаких проблем.

Для начала мы добавим css класс `edit` для ссылок на редактирование картинок,
так чтобы мы могли обработать их точно тем же способом как мы делали это реализуя
удаление картинок.

    // _picture.html.erb
    ....
      link_to 'Edit', edit_picture_path(picture), :class => 'edit', //...


    // index.html.erb
    function hijack_links() {
      // delete links processing in here
  
      $$("#pictures a.edit").each(function(link) {
        link.onclick = function(event) {
          event.stop();
          Xhr.load(this.href + ".js");
        }
      });
    }

В данном случае на не нужно трогать наш контроллер для генерации ответа,
мы можем просто создать шаблон `edit.js.erb` и добавить еще одну функцию
которая будет делать необходимые изменения на странице.

    // edit.js.erb
    show_edit_form(&lt;%= @picture.id %>, "&lt;%= escape_javascript(render("form")) %>");


    // index.html.erb
    function show_edit_form(id, source) {
      $$('form.edit_picture').each('remove'); // nuking any old forms
  
      remotize_form(
        $('picture_'+id).insert(source)
          .first('form.edit_picture').show('fade')
      );
    }

Скрипт очень прост. Он удаляет любые старые формы возможно болтающиеся с других
операций, затем он вставляет полученный код формы на страницу, затем инциализирует
и показывает форму для редактирования.

Обработка сохранения изменений, точно такая же как обработка создания новых
картинок. Мы добавляем обработчик запросов `.js` в методе  `update` нашего контроллера

    def update
      ....
      respond_to do |format|
        ....
        format.js   { render :layout => 'iframed', :content_type => 'text/html' }
      end
    end

И создаем шаблон `update.js.erb` с очень похожим вызовом функции JavaScript.

    // update.js.erb
    &lt;% if @picture.valid? %>
      update_picture(&lt;%= @picture.id %>, "&lt;%= escape_javascript(render(@picture))%>");
    &lt;% else %>
      replace_form('edit_picture_&lt;%= @picture.id%>', "&lt;%= escape_javascript(render('form')) %>");
    &lt;% end -%>


    // index.html.erb
    function update_picture(id, source) {
      $('picture_'+id).replace(source);
  
      hijack_links();
    };

Вот вобщем то и все. Полностью функциональная ajax фото галлерея готова.


## Выводы, :summary

Окей, это возможно была достаточно длинная статья для статей подобного рода, но если
вы оглянитесь назад, вы можете увидеть, насколько рационально мы использовали все
уже существующие шаблоны и реализовали все процессы всего в несколько коротких
и простых JavaScript функций.

Мы так же были очень unobtrusive, ничего не сломали и оставили всю оригинальную функциональность
на месте, так, что наш пользователь теперь имеет вы бор, использовать ли удобства
ajax, или использовать старый интерфейс.

Мы так же собрали небольшую библиотеку JavaScript функций, которая может свободно
эволюционировать и быть использована совместно с другими страницами.


## Дальнейшие шаги, :further

Если вы скачаете исходный код данного примера, вы найдете полностью законченное
приложение в котором реализовано еще несколько проблем, как-то использование виджета
Lightbox, обработка спиннеров, дополнительные визуальные эффекты и пр.

Теперь, когда вы знаете базовые принципы, вы сможете легко во всем разобраться.
