# Работа с событиями DOM
<% set_unit_scope('Element') %>

RightJS имеет общий интерфейс для работы с событиями - {Observer} и все dom-элементы используют его
для работы. Это означает, что вы можете назначать обработчики событий тем же точно способом что и везде

    $('element').on('click', function() {});
    $('element').on('click', [func1, func2, func3,...]);
    $('element').on({
      click:     func1,
      mouseover: func2,
      mouseout:  func3
    });
    
    // ссылки по имени так же работают
    $('element').on('click', 'addClass', 'clicked');
    
Так же, для всех стандартных dom-событий существует набор сокращений

    $('element').onClick(function() {})
    $('element').onMouseover('addClass', 'hovered');
    $('element').onMouseout('removeClass', 'hovered');
    
    $('form').onSubmit(function() {});
    
    $('input').onChange(function() {});
  
И вы так же можете отключать слушателей стандартным способом

    $('element').stopObserving('click');
    $('element').stopObserving(function_1);
    $('element').stopObserving('click', function_2);
    
    $('element').observes('click');
    $('element').observes(function_1);
    
    // ....

См. описание модулей {Observer} и {Element} с методами {#on}, {#stopObserving}, {#observes}, {#listeners}
для более детальной информации по стандартному интерфейсу.


## Получение объекта события, :receiving

Есть пара важных моментов о том, как RightJS посылает объекты событий в методы слушателей.

Когда вы подключаете слушателя в виде функции, обычным способом. RightJS работает в стандартном режиме,
он вызовет функцию слушателя в контексте данного элемента и передаст объект события первым аргументом в списке.

    $('element').onClick(function(event) {
      if (this.hasClass('marked'))
        event.stop(); // или что там у вас
    });

Вы так же можете предустановить несколько атрибутов которые необходимо послать слушателю вместе
с объектом события. В данном случае не нужно ничего придумывать, просто укажите аргументы следом за функцией

    $('element').onClick(function(event, one, two, three) {
      this.update(one + two + three);
    }, 'one', 'two', 'three');

__НО__, если вы указываете обработчик события по имени, RightJS пошлет в него _только те аргументы_ которые
вы укажите при инициализации. Причина в том, что методы указываемые по имени, ожидают некоторые данные, а не объект события.

    $('element').onClick('hide', 'fade', {duration: 'long'});
    $('element').onMouseover('addClass', 'hovered');
    $('element').onMouseout('removeClass', 'hovered');


## Расширения событий, :extensions

RightJS не создает никакого прокси-интерфейса для работы с событиями в кросс-браузерном стиле.
Вместо этого, он исправляет события Internet Explorer, добавляя к ним стандартные для w3c свойства.

Это означает, что с каким бы браузером вы не работали, вы всегда будете иметь следующий список атрибутов.

* `which` - номер нажатой кнопки мыши (1,2,3)
* `target` - ссылка на элемент вызвавший событие
* `currentTarget` - ссылка на элемент слушателя события
* `relatedTarget` - ссылка на зависимый элемент для событий mouseover и mouseout
* `pageX`, `pageY` - абсолютная позиция курсора

В дополнение каждый объект события будет иметь пару стандартных методов {Event#stop} и {Event#position},
для остановки событий и для того чтобы получать их позицию соответственно.

Если вы используете w3c стандартный браузер или пользуетесь интерфейсами RightJS для назначения слушателей,
то все расширения будут доступны прозрачно и сразу

    $('element').onContextmenu(function(event) {
      event.stop();
      
      $('context-menu').moveTo(event.position()).show('slide');
    });
  
Но если вы по каким либо причинам назначили слушателя используя интерфейсы браузера IE напрямую,
то для того, чтобы получить доступ к расширениям, вам необходимо будет вызвать метод {Event.ext}
на объекте события

    element.attachEvent('onclick', function(event) {
      Event.ext(event);
      
      event.stop();
    });


## Запуск событий вручную, :triggering

Любое событие в RightJS может быть инициировано вручную, что не является вполне чистым подходом в плане
работы с dom-событиями, но иногда бывает очень полезным. Для того чтобы запустить событие, вам нужно
вызвать метод `fire` указав имя события и возможно несколько опций

    $('element').onClick(function() { alert('boo'); });
    
    $('element').fire('click'); // вы увидите алерт 'boo'
    
    
    // или скажем вы можете эмулировать нажатие клавиши
    $('element').fire('keypress', {keyCode: 27});

__ВНИМАНИЕ__: RightJS _не запускает_ реальных событий в данном случае. Данный метод просто оповещает
всех зарегистрированных слушателей с искусственным объектом события.


## Нестандартные события, :custom

В целом, для RightJS, нет никакой разницы между стандартными и нестандартными событиями. Все они 
будут обработаны в едином виде

    $('element').on('my-event', function() {...});
    
    $('element').onClick(function() {
      if (something)
        this.fire('my-event', {with: 'options'});
    });

Единственная разница в том, что для нестандартных событий нет сокращенных методов.
