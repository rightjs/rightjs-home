# Визуальные эффекты
<% set_unit_scope('Fx.Element') %>

По умолчанию RightJS идет со встроенным движком визуальных эффектов и несколькими,
самыми часто используемыми эффектами. И т.к. RightJS - по большому счету 
объектно ориентированная библиотека, все эффекты в ней это по сути классы которые
могут быть лекго наследованы, расширены и т.п. Имеются так же свой набор опций,
методы для сокращенного создания эффектов и т.п.

В этой статье мы рассмотрим основные вопросы по теме работы с ними.

## Базовый интерфейс Fx.Morph, :generic

Класс {Fx.Morph} это базовый класс и основа для всех остальных визуальных эффектов в RightJS.
Он предоставляет общий интерфейс позволяющий плавно изменять стили любого элемента
от их текущего состояния до любого нового.

    new Fx.Morph('element').start({
      background: 'yellow',
      width:      '200px'
    });

    new Fx.Morph('element', {
      duration: 'short', transition: 'Sin'
    }).start({...});

Вы можете свободно использовать стили в любой стандартной для css нотации, указывать
несколько стилей в одном, как например `border: 10px solid yellow` или `margin: 1px 2px 3px 4px`,
можете использовать цвета в любом доступном формате, а так же использовать любые из 12-ти
стандартных их названий. Размеры могут быть в любых единицах, но лучше использовать пикселы
или поинты. т.к. Opera браузеры округляют значения в `em` при их считывании
и не дают правильно работать с маленькими элементами в районе 1em.

Вы можете указывать столько стилей, сколько пожелаете, все они будут обработаны синхронно
в одном эффекте

## Список опций, :options

Базовый конструктор визуальных эффектов может получать следующие опции

Имя        | Умолчание  | Описание
-----------|------------|----------------------------------------------------
duration   | 'normal'   | длительность эффекта (название или число в мс)
transition | 'Sin'      | алгоритм переходов
queue      | true       | маркер, если эффект должен встать в очередь


Длительность может быть одним из следующих

* 'short'  - 200 мс
* 'normal' - 400 мс (по умолчанию)
* 'long'   - 800 мс
* любое целое число отражающее длительность в миллисекундах

Алгоритмы переходов доступны следующие

* 'Cos' - медленный в середине, быстрый в начале и конце
* 'Sin' - медленный на концах, быстрый в середине
* 'Exp' - медленный в начале и убыстряющийся к концу
* 'Log' - быстрый в начале и замедляющийся к концу
* 'Lin' - переход с постоянной скоростью
* вы так же можете указать любую собственную функцию

## Список событий, :events

Каждый эффект имеет интерфейс {Observer} и вы можете подключать к ним слушателей следующих событий

* start
* finish
* cancel

## Коллекция эффектов по умолчанию, :frequently

По умолчанию RightJS предоставляет следующие простые эффекты уже реализованными

* {Fx.Highlight}
* {Fx.Fade}
* {Fx.Slide}
* {Fx.Scroll}

Все они являются подклассами {Fx.Morph} и имеют тот же самый интерфейс

    new Fx.Highlight('element').start();
    
    new Fx.Fade('element').start();
    
    new Fx.Slide('element').start();


## Двунаправленные эффекты, :bidirectional

Эффекты {Fx.Fade} и {Fx.Slide} относятся к семейству двунаправленных эффектов и могут работать
в двух направлениях, на показ и на скрытие элементов. По умолчанию, они автоматически определяют
текущее состояние элемента и работают в противоположном направлении, но вы можете так же указать
направление работы вручную.

    // hide -> show -> hide -> show
    new Fx.Fade('element').start();
    new Fx.Fade('element').start();
    new Fx.Fade('element').start();
    new Fx.Fade('element').start();


    // hide -> hide -> show -> show
    new Fx.Slide('element').start('out');
    new Fx.Slide('element').start('out');
    new Fx.Slide('element').start('in');
    new Fx.Slide('element').start('in');


## Сокращенный вызов эффектов, :shortcuts

Существует несколько коротких методов, позволяющих вам запускать эффекты непосредственно
от dom-элементов без создания объектов вручную

* {Fx.Element#morph}(mixed style[, Object fx_options])
* {Fx.Element#highlight}([end_color[, start_color[, Object fx_options]]])
* {Fx.Element#fade}([String direction[, Object fx_options]])
* {Fx.Element#slide}([String direction[, Object fx_options]])
* {Fx.Element#scroll}(Object position);

Несколько примеров

    $('element').morph({background: 'green'});

    $('element').highlight();

    $('element').fade();

    $('element').slide();

Дополнительно, вы можете посылать имя эффекта напрямую в методы элементов `hide/show/toggle/radio`.

    $('element').hide('slide');
    $('element').show('fade');

    $('element').toggle('slide', {
      direction: 'left', duration: 'long'
    });


## Очередь эффектов, :queueing

По умолчанию RightJS будет ставить визуальные эффекты в очередь, так что вы можете
легко создавать последовательности эффектов в коде

    $('element').morph({
      width: '400px', fontSize: '40px'
    }).highlight();

    $('element').show('fade').highlight();

Но в случае если вам необходимо запустить два и более эффекта одновременно, вы можете указать
опцию `queue: false`. В этом случае эффект будет запущен незамедлительно. 

    new Fx.Morph('element').start({width: '400px'});
    new Fx.Highlight('element', {queue: false}).start();

    $('element').fade('out', {queue: false});


## Собственные эффекты, :custom

Т.к. визуальные эффекты в RightJS имеют нормальную объектно-ориентированную структуру,
а класс {Fx.Morph} предоставляет интерфейс для работы с любыми стилями,
то используя наследование, можно очень легко и быстро создавать свои собственные эффекты,
которые будут делать в точности то что вам необходимо.

Например взгляните на эффект градусника на [странице пользовательских сборок](<%= builds_path %>).
Тот что показывает размер сборок справа. По идее это просто `morph` эффект, но там
так же происходит подсветка другим цветом, а так же меняются цифры во время работы.

Создавать собственные эффекты очень просто. В базовом интерфейсе существует два метода,
которые вам необходимо реализовать `prepare` и `render`, первый из них вызывается непосредственно
перед запуском эффекта когда до него доходит очередь; он получает все те же аргументы что и
метод `start`. Второй метод, это то место где собственно происходят трансформации. Во время
работы эффекта этот метод получает числа от `0` до `1`, указывающие на относительную позицию
эффекта от начала до конца.

Например тот эффект со страницы пользовательских сборок выглядит примерно вот так.

    var CalcFx = new Class(Fx.Morph, {
      prepare: function(start_size, end_size) {
        this.startSize = start_size;
        this.endSize   = end_size;

        this.element.highlight('brown', '#8A7', {queue: false});

        this.$super({
          height: $('calc-box').sizes().y * (end_size/max_size) + 'px'
        });
      },

      render: function(delta) {
        var size = this.startSize + (this.endSize - this.startSize) * delta;
    
        $('calc-num').update((size/100).round()/10 + 'k');

        this.$super(delta);
      }
    });

