# Единообразная обработка событий

RightJS имеет совместно используемый модуль {Observer} отвечающий за функциональность работы
с событиями. Он используется во всех случаях где происходит работа с событями, как-то классы
{Xhr}, {Fx}, элементы DOM такие как {Element}, {Form}, {Document}, а так же все модули из
библиотек [Goods](/goods) и [UI](/ui).

Использование единого совместно используемого модуля, позволяет обрабатывать события во
всех случаях единообразно.


## Основы использования, :usage

Модуль {Observer} содержит все стандартные методы для назначения, удаления и проверки
слушателей, а так же инициации событий. Поэтому когда вы видите список поддерживаемых
событий, например для класса [Draggable](/goods/drag-n-drop/draggable#events),
вы можете сразу начать их использовать, со всеми доступными методами наблюдателя

    new Draggable().on('start', function() {....});
    
    // в виде хэша
    new Draggable().on({
      start: function1,
      drag:  function2,
      drop:  function3
    });
    
    // использовать ссылки по имени
    new Draggable().on('start', 'revert');
    
    // использовать коллекции слушателей
    new Draggable().on('start', [function1, function2]);
    new Draggable().on({
      start: [function1, function2],
      stop:  [function3, function4]
    });
    
    // и вы можете предустановить дополнительные аргументы
    new Draggable().on('start', func1, val1, val2, ...);

Все точно тоже верно и для DOM элементов

    $('my-id').on('click', function() {...});
    
    $('my-id').on('click', 'addClass', 'marked');
    
    $('my-id').on({
      click:     func1,
      mouseover: 'highlight',
      mouseout:  [func2, func3, funcc4]
    });

Далее для предустановленного набора событий и для всех стандартных событий dom, существуют так же
сокращенные методы вида `on[Event]`.

    new Draggable().onStart(func1).onStop(func2).onDrag('revert');
    
    $('my-id').onClick(function(){}).onMouseover('addClass', 'hovered');

Так же для предустановленного набора событий, вы можете указывать ваших слушателей совместно
с остальными опциями конструктора используя ключи подобные именам сокращенных методов

    new Draggable({
      axis:    'x',
      snap:    10,
      onStart: function1,
      onStop:  function2
    });
    
    new Autocompleter('my-element', {
      url:      '/some/url',
      onShow:   function1,
      onSelect: function2
    });

Единственное исключение - конструктор класса {Element}. Для того чтобы ускорить программную
сборку элементов, вы должны указывать своих слушателей с ключом `events` используя точно такой же
вид хэшей какой бы вы указали для метода `on`

    new Element('div', {
      id: 'my-id',
      events: {
        click:     function() {},
        mouseover: function() {}
      }
    });

## Нестандартные события, :custom

В нашей системе нет никакой разницы между стандартными и нестандартными событиями. Вы можете
назначать слушателей и инициировать любые нестандартные события точно тем же способом что 
и стандартные. Единственно не будут доступны сокращенные методы и опции для конструктора.

    var calendar = new Calendar();
    
    // назначаем слушателя нестандартного события
    calendar.on('my-event', function(one, two, three) {
      // делаем что-то по этому поводу
    });
    
    // инициируем нестандартное событие
    calendar.fire('my-event', 1,2,3);

