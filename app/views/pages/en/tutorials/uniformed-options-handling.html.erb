<h1>Uniformed Options Handling</h1><% @title_text = "Tutorials: Uniformed Options Handling" %>
<p>
  RightJS has its own conventional way to process options in all the configurable units like {Xhr}, {Fx}, {Cookie} and
  all the modules out of the the <%= link_to "goods", '/goods' %> and <%= link_to 'ui', '/ui' %> libraries.
</p>
<p>
  For this purpose there is a simple shared module called {Options}. All the RightJS units use it and so can you.
</p>

<%= chapter "Convention", :convention %>
<p>
  The {Options} module might be used in several different ways, but in order to organize the things in a single
  uniformed way, we use the following convention.
</p>
<p>
  Every configurable class has a class-level property called <tt>Options</tt>, which is a simple hash that contains
  the default options for the class instances. That what it will have if you won't specify any options at all.
</p>
<p>
  For example the {Xhr} class has the <tt>Options</tt> property that looks like that
</p>
<code>
Xhr.Options = {
  method:   'post',
  encoding: 'utf-8',
  ....
}
</code>
<p>
  When you create an instance of a configurable class, the options you send into its constructor, will be <u>merged</u>
  with the default ones, and then the instance will have a property called <tt>options</tt> (downcased), which will
  contain the actual merged options of your object.
</p>
<code>
// with default options
var xhr = new Xhr();
xhr.options.method   -> 'post'
xhr.options.encoding -> 'utf-8'


// with custom options
var xhr = new Xhr({method: 'get'});
xhr.options.method   -> 'post'
xhr.options.encoding -> 'utf-8'
</code>


<%= chapter "Alterations", :alterations %>
<p>
  Having such a conventional way, gives you a good flexibility over your application configuration.
</p>
<p>
  When you see a list of supported options for a class, say like <%= link_to "Calendar widget options", "/ui/calendar#options" %>
  You can feed each constructor with any of those options like that
</p>
<code>
var calendar = new Calendar({
  format: 'US',
  firstDay: 0
});

calendar.options.format   -> 'US'
calendar.options.firstDay -> 0
</code>
<p>
  Or you can alter the <tt>Calendar.Options</tt> object and change behavior of all the class instances in a single place like that
</p>
<code>
$ext(Calendar.Options, {
  format: 'US',
  firstDay: 0
});

// after that
var calendar = new Calendar();
calendar.options.format   -> 'US'
calendar.options.firstDay -> 0
</code>
<p>
  Those principles work all over the framework with all the configurable classes.
</p>


<%= chapter "RigthJS UI Library Options", :ui %>
<p>
  All the <%= link_to "RightJS UI", "/ui" %> library units can be initialized without actual writing any JavaScript code,
  all of them have their own markers, like custom <tt>rel</tt> attributes or css-classes, so that when the page is loaded
  the scripts could automatically find your elements and do all the initializations, for example you can initialize a
  calendar over an input field like that
</p>
<code>
<input type="text" rel="calendar" />
</code>
<p>
  But in case you need some customization for that kind of elements there is a conventional way of doing that.
</p>
<p>
  All you need is to create a custom HTML5 like attribute that named like <tt>data-[unit-name-here]-options</tt> and
  set your options inside it in a JSON format. For example
</p>
<code>
// a calendar field
<input rel="calendar" data-calendar-options="{format:'US'}" />

// autocompleter
<input type="text" rel="autocompleter"
  data-autocompleter-options="{url:'/my/url'}">

// or a lightbox link
<a rel="lightbox" data-lightbox-options="{blockContent: true}">
  <img src="/.../..." />
</a>
</code>
<p>
  When a script will process your element it will automatically check the attributes and try to use them as options.
</p>
<p>
  This principle works with all auto-discoverable units out of the <%= link_to 'UI', '/ui' %> and <%= link_to 'Goods', '/goods'%> libraries
</p>