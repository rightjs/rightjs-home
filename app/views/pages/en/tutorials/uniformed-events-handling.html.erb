<h1>Uniformed Events Handling</h1><% @title_text = "Tutorials: Uniformed Events Handling" %>
<p>
  RightJS has a shared module called {Observer} that handles all the functionality of
  observable units that need to process some events. That includes {Xhr}, {Fx}, DOM units like
  {Element}, {Form}, {Document}, and all modules out of the <%= link_to 'Goods', '/goods' %>
  and <%= link_to 'UI', '/ui' %> libraries.
</p>
<p>
  All of them works via the same interface and uses the same set of features.
</p>


<%= chapter "Usage Basics", :usage %>
<p>
  The {Observer} module has all the standard methods to assign, remote, check and trigger events.
  So when you see a list of supported by a unit events, like say <%= link_to 'Draggable', '/goods/drag-n-drop/draggable#events' %>
  you can use them right away like this
</p>
<code>
new Draggable().on('start', function() {....});

// you can use hashes
new Draggable().on({
  start: function1,
  drag:  function2,
  drop:  function3
});

// you also can use self-references like that
new Draggable().on('start', 'revert');

// and lists of callbacks
new Draggable().on('start', [function1, function2]);
new Draggable().on({
  start: [function1, function2],
  stop:  [function3, function4]
});

// you can pre-bind some values for your callbacks
new Draggable().on('start', func1, val1, val2, ...);
</code>
<p>
  Pretty much the same for any DOM elements.
</p>
<code>
$('my-id').on('click', function() {...});

$('my-id').on('click', 'addClass', 'marked');

$('my-id').on({
  click:     func1,
  mouseover: 'highlight',
  mouseout:  [func2, func3, funcc4]
});
</code>
<p>
  The for predefined events list and the most common dom-events there will be shortcut methods
  named like <tt>on[Event]</tt>. Note each of them returns the object back so you can write chains like that
</p>
<code>
new Draggable().onStart(func1).onStop(func2).onDrag('revert');

$('my-id').onClick(function(){}).onMouseover('addClass', 'hovered');
</code>
<p>
  For the predefined events list with all the units you can send your callbacks along with the options,
  using the same names as the short-cut methods
</p>
<code>
new Draggable({
  axis: 'x',
  snap: 10,
  onStart: function1,
  onStop:  function2
});

new Autocompleter('my-element', {
  url: '/some/url',
  onShow:   function1,
  onSelect: function2
});
</code>
<p>
  The only exception is the the DOM {Element} constructor, to speed the things up, you need to use
  an option named <tt>events</tt> with the same hash of callbacks you would send to the <tt>on</tt> method
</p>
<code>
new Element('div', {
  id: 'my-id',
  events: {
    click:     function() {},
    mouseover: function() {}
  }
})
</code>

<%= chapter "Custom Events", :custom %>
<p>
  In our system there is no difference between custom and predefined list of events. You can define
  and trigger your own events on fly, just like that
</p>
<code>
var calendar = new Calendar();

// assign it
calendar.on('my-event', function(one, two, three) {
  // do something about it
});

// fire it
calendar.fire('my-event', 1,2,3);
</code>
<p>
  This is pretty much it.
</p>