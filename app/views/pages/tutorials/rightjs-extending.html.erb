<h1>RightJS Extending Guide</h1><% @title_text = "Tutorials: RightJS Extending Guide" %>

<p>
  In case you'd like to write some extension for RightJS, like a plugin or just some tiny library
  to organize routine operations on your application, here is a simple guidance how you could do that.
</p>

<p>
  In terms of functionality extending you should be aware of three types of units
  <ul>
    <li><a href="#natives">JavaScript Natives</a></li>
    <li><a href="#rightjs">RightJS Classes</a></li>
    <li><a href="#dom">DOM Level Units</a></li>
  </ul>
  We will get through them one by one and later I'll put some words in about methods overloading.
</p>


<%= chapter "JavaScript Natives Extending", :natives %>
<p>
  When we are talking about extending the native units like {String}, {Array}, {Function} etc.
  we are talking about extending the object prototypes. So the extension of natives is
  simple. Just use the <tt>$ext</tt> method on the unit prototype.
</p>
<code>
$ext(Array.prototype, {
  myMethod1: function() { return 1; },
  myMethod2: function() { return 2; }
});

[1,2,3,4].myMethod1(); // -> 1
[1,2,3,4].myMethod2(); // -> 2


$ext(String.prototype, {
  hasBoo: function() {
    return this.includes('boo');
  }
});

"moo".hasBoo(); // -> false
"boo".hasBoo(); // -> true
</code>


<%= chapter "RightJS Own Classes Extending", :rightjs %>
<p>
  The are few RightJS own classes in the core, like {Xhr}, {Fx}, {Cookie}. All of them are based on the {Class} unit,
  which means you can use the RightJS OOP features to extend them. Meaningly the <tt>include</tt> and <tt>extend</tt> methods.
</p>
<p>
  In similar with the Ruby programming language, the <tt>include</tt> method extends the class instance level, which is
  the prototype level in our case. And the <tt>extend</tt> method extends the class level by itself.
</p>
<code>
Xhr.include({
  myMethod: function() {}
});

new Xhr('/some/url').myMethod();

Xhr.extend({
  MY_CONSTANT: 1
})

if (Xhr.MY_CONSTANT) {
  new Xhr('/some/url');
}
</code>
<p>
  You can feed those methods with several modules if you like
</p>
<code>
Xhr.include(MyModule1, MyModule2, ...);
Xhr.extend(MyModule1, MyModule2, ...);
</code>
<p>
  If it doesn't feel much natural, you can use the usual approach too.
</p>
<code>
$ext(Xhr, {...});           // same as Xhr.extend
$ext(Xhr.prototype, {...}); // same as Xhr.include
</code>



<%= chapter "DOM Level Extending", :dom %>
<p>
  As there are more than one implementation of the DOM level units, extending them might be tricky.
  For this reason RightJS provides the {Element.addMethods} feature, which might be used like this.
</p>
<code>
Element.addMethods({
  myMethod1: function() {},
  myMehtod2: function() {}
});

$('my-element').myMethod1();
$$('*').each('myMethod2');
</code>
<p>
  Once you called the feature all your extensions will be registered and then whenever you select
  an element with RightJS methods you will have them available on the element.
</p>
<p>
  There are few more features like this
  <ul>
    <li>{Form.addMethods} - extends the FORM elements only</li>
    <li>{Form.Element.addMethods} - extends INPUT, SELECT and TEXTAREA elements only</li>
    <li>{Event.addMethods} - extends the dom events</li>
  </ul>
</p>
<p>
  All those methods will register your extensions inside the objects and extend the units
  prototype level if available, so that your methods will work exactly the same way as any
  RightJS own method works.
</p>


<%= chapter "Methods Overloading", :overloading %>
<p>
  Sometimes you might need not just to add some new methods but overload existing ones,
  here is a tip how you could do that.
</p>
<p>
  The idea is simple, you create a temporary function, that will return the end hash with
  extensions, and then you instantly call it with the unit you extend, like this:
</p>
<code>
$ext(SomeClass.prototype, (function(class_prototype) {
  var old_method = class_prototype.someMethod;
  
  return {
    someMethod: function() {
      var result = old_method.apply(this, arguments);
    
      // do something more
    
      return result;
    }
  };
})(SomeClass.prototype));
</code>
<p>
  The reason of doing that is to have a standalone namespace where you could safely separate
  the old methods and keep them alive for future calls.
</p>
<p>
  For example, say I want that the {Xhr} instances did some fancy stuff before sending the requests
</p>
<code>
Xhr.include(function(xhr_prototype) {
  var old_send = xhr_prototype.send;
  
  return {
    send: function() {
      this.fancyStuff();
      
      return old_send.apply(this, arguments);
    },
    
    // my additional method with the fancy stuff
    fancyStuff: function() {
    }
  };
  
})(Xhr.prototype));
</code>
<p>
  In case of the dom-level units, all the additional methods are stored at constants called <tt>Methods</tt>,
  like <tt>Element.Methods</tt>, <tt>Form.Methods</tt>, <tt>Event.Methods</tt>. You can use them instead of
  prototypes in the overloading process.
</p>
<p>
  For example I would like to know when something on the page was changed.
</p>
<code>
var call_mommy = function(element) {...};

Element.addMethods((function(old_methods) {
  var old_insert = old_methods.insert;
  
  return {
    insert: function() {
      var result = old_insert.apply(this, arguments);
      
      call_mommy(this);
      
      return result;
    }
  };
})(Element.Methods));
</code>
<p>&nbsp;</p>
<p>
  This is pretty much all about the RightJS extending techniques.
</p>