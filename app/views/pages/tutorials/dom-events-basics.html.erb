<h1>DOM Events Handling Basics</h1><% set_title('Tutorials: Visual Effects'); set_unit_scope('Element') %>

<p>
  In general, dom-events handling with RightJS is a pretty much standard thing. There is the
  basic interface with methods {#observe}, {#observes} and {#stopObserving} that you might see in
  most of the JavaScript frameworks and the use cases for them are quite usual.
</p>
<code>
var callback = function(event) {....};

$('element').observe('click', callback);
$('element').observes(callback);
$('element').stopObserve(callback);
</code>
<p>
  As usual you can use any format of your event names with or without the <tt>'on'</tt> prefix.
</p>
<code>
$('element').observe('click', function() {...});

// is equal to

$('element').observe('onclick', function() {...});
</code>
<p>
  And RightJS automatically chooses the correct event name depend on the current browser.
</p>
<code>
$('element').observe('contextmenu', function() {...});

$('element').observe('rightclick', function() {...});
</code>
<p>
  And as usual all the callbacks are called in the context of the element, so you can easily do short things like that.
</p>
<code>
$('element').observe('click', function() {
  this.toggleClass('marked');
  
  alert(this.innerHTML);
});
</code>
<p>
  And again in a standard way you can stop your events from bubbling by calling the <tt>stop()</tt> method
</p>
<code>
$('element').observe('click', function(event) {
  event.stop();
  
  // or
  event.preventDefaults();
  event.stopPropagation();
});
</code>
<p>
  This is pretty much all the standard features you might see at most of the frameworks. Now lets get to the new features.
</p>

<h2>Event Listeners Connection Additionals</h2>
<p>
  I'm sure there was a moment when you felt tired of writing <tt>observe('blablabla')</tt> all the time. So lets help you
  a little bit. First of all there is a short alias for the {#observe} method called {#on}. The code with the thing sounds quite natural
</p>
<code>
$('element').on('click', function() {...});
$('element').on('mouseover', function() {...});
</code>
<p>
  Additionally, for the most common events there are even shorter shortcuts, like this
</p>
<code>
$('element').onClick(function() {...});
$('element').onKeydown(function() {...});
</code>
<p>
  This thing might sound a bit dangerous, because there are properties of the element with just the same name but downcased,
  which you can assign to callbacks. But that's not so scary in reality. You won't be able to break your logic with this
  feature, because if you won't be able to call the native properties as methods and will have a runtime error.
</p>
<p>
  Well, anyway, you always have a choice. Use the feature and have more compact and readable code or don't use and have
  a safer feeling in your guts.
</p>

<h2>Attaching Several Event Listeners In A Single Call</h2>
<p>
  Additionally you might specify several event handlers in a single call
</p>
<code>
$('element').on({
  click: function() {...},
  mouseover: function() {...}
});
</code>
<p>
  You might do just the same thing when you instance new elements
</p>
<code>
new Element('div', {
  observe: {
    click: function() {...},
    keydown: function() {....}
  }
});
</code>

<h2>Arguments Presetting</h2>
<p>
  With RightJS you don't need to bind additional arguments which you might need to pass into your event listeners manually.
  You can just pass them as optional arguments to the {#observe} or {#on} methods.
</p>
<code>
// a simple chess board
'abcdefjh'.split('').each(function(letter) {
  '12345678'.split('').each(function(number) {
    
    // the usual way of doing the thing would be like this
    $('cell-'+letter+number).onClick((function(event, letter, number) {
      alert(letter + number);
    }).bindAsEventListener(letter, number));
    
    // instead you might do the same like this
    $('cell-'+letter+number).onClick(function(event, letter, number) {
      alert(letter + number);
    }, letter, number);
  });
});
</code>
<p>
  The second version is not just shorter and more readable, but will actually work faster, because there will be no
  additional binding wrapper. Instead of that the callback will be called directly with those arguments.
</p>

<h2>Listeners Assignment By Name</h2>
<p>
  I'm sure there heaps and heaps of cases when what you need from a listener is just to call the same element method
</p>
<code>
$('element').on('click', function() {
  this.addClass('marked');
  
  this.disable();
  this.enable();
  
  // .....
});
</code>
<p>
  RightJS has the common feature <%= link_to 'call by name', tutorial_path('call-by-name') %>, add there just
  described ability to preserve arguments for your event listeners and you will have one of the sweetest features
  of RightJS.
</p>
<code>
$('element').onClick('toggleClass', 'marked');

$('element').onMouseover('setStyle', 'background: #DDD');

$('form').onSubmit('disable');

$('input').onClick('enable');

// or you might add some chains for more fun
$E('div').inserTo(document.body
  ).onMouseover('setStyle', 'border: 1px solid grey'
  ).onMouseout('setStyle', 'border:none'
  ).onClick('highlight', 'blue');
</code>
<p>
  Those things are not just short and much more readable, but they will work faster than if you did the same thing
  the old way with a proxy function, because there will be no proxy function, element methods will get
  called directly.
</p>

<h2>Callbacks Attachment Check</h2>
<p>
  To check if an element observes a particular callback, there is the method called {#observes}, in general case
  it is get called the following way.
</p>
<code>
var callback1 = function() {};
var callback2 = function() {};

$('element').on('click', callback1);

$('element').observes(callback1); // -> true
$('element').observes(callback2); // -> false
</code>
<p>
  But you can use just the same method to check if and element has listeners for some event name
</p>
<code>
$('element').on('click', function() {....});

$('element').observes('click');     // -> true
$('element').observes('mouseover'); // -> false
</code>
<p>
  And with just the same method you can check if an element has a particular listener attached to particular event name
</p>
<code>
var callback = function() {..};

$('element').on('click', callback);

$('element').observes('click', callback);    // true
$('element').observes('mouseover' callback); // -> false
</code>

<h2>Listeners Detaching</h2>
<p>
  There is a method {#stopObserving} which you call when you need the element to stop observe some callback
</p>
<code>
var callback = function() {...};

$('element').on('click', callback);

$('element').stopObserving(callback);

// the element ain't observe the callback anymore
</code>
<p>
  You can use just the same method to detach all the listeners of the element for a particular event name
</p>
<code>
var callback1 = function() {};
var callback2 = function() {};

$('element').on('click', callback1);
$('element').on('click', callback2);

$('element').stopObserving('click');

// both of the callbacks were detached from the element
</code>
<p>
  And you use the same method again if you need to detach a callback from a particular event
</p>
<code>
var callback = function() {};

$('element').on('click', callback);
$('element').on('mouseover', callback);

$('element').stopObserving('click', callback);

// the callback was detached from the 'click' event,
// but still observes the 'mouseover' event
</code>

<h2>Manual Events Firing</h2>
<p>
  There is a method called {#fire} in RightJS that lets you manually trigger any events on your
  elements if you need so.
</p>
<code>
$('element').onClick('addClass', 'clicked');

$('element').fire('click');

$('element').hasClass('clicked'); // -> true
</code>
<p>
  You can also specify some options for your events
</p>
<code>
$('input').onKeydown(function(event) {
  if (event.keyCode == 8) {
    alert('The key with code 8 was pressed down!');
  }
});

$('input').fire('keydown', {keyCode: 8});
</code>
<p>
  For the most common events there are shortcut methods to initiate the events
</p>
<code>
$('input').click({shiftKey: true});
$('input').keypress({keyCode: 22});
</code>
<p>
  <b style="color: grey">NOTE:</b> with the default build this feature uses a dummy event,
  although it will call all the listeners, and monkey the basic interface, this is not the
  real thing, but a mock.
</p>


<h2>Custom Events Support</h2>
<p>
  With RightJS you are free to define any custom events you want for your elements. And basically
  there are no difference between the native and custom events, you can handle them transparently
  through just the same interface.
</p>
<code>
$('element').on('myevent', function() { console.log('I hear ya!') });
$('element').on('myevent', function() { console.log('I hear ya too!') });

$('element').onClick('addClass', 'clicked');
$('element').onMouseout(function() {
  if (this.hasClass('clicked'))
    this.fire('my-event');
});
</code>
<p>
  Now when you clicked on an element and then moved the mouse out, the element will call all
  the listeners of the <tt>'myevent'</tt> event.
</p>
<p>
  Basically you use the feature when you need to split and separate some logic and notify
  listeners only on some conditions.
</p>