<h1>Ajaxed Photo Gallery</h1><% @title_text = "Tutotirals: Ajaxed Photo Gallery" %>

<p>
  In this tutorial we will take a look at things in complex and develop some
  ajaxed web photo gallery using RightJS and the Ruby On Rails framework.
</p>
<p>
  We will use Ruby On Rails as it is current industry standard in its own way,
  but most of the things are applicable to any other framework and meant to display
  basic technics when you do things with RightJS, like files uploading, page alterations, etc.
</p>

<h2>The Source Code Download</h2>
<p>
  You can grab the whole project at this repository at the github service
</p>
<p>
  <a href="http://github.com/MadRabbit/right-gallery" target="_blank">http://github.com/MadRabbit/right-gallery</a>
</p>
<p>
  <tt>git clone git://github.com/MadRabbit/right-gallery.git</tt>
</p>
<p>
  It's just a simple ruby-on-rails application, I'm sure you can find out how to fire it up and play with the thing.
</p>

<h2>The Strategy</h2>
<p>
  There are many ways to implement the feature, some of them more simpler than others, but we will use
  a kind of mixed approach. We will start with a standard working CRUD controller and basic functionality
  and create a JavaScript wrap up over it.
</p>
<p>
  The target is to implement a transparent ajaxed functionality the way that the original one was still
  available, so that the user could always hit the right mouse button and choose to open the links in 
  new tab or window or give a link for another user to edit or create new pictures in the gallery.
</p>
<p>
  We also aim to make a great deal of the original templates reusage and javascript code simplicity.
</p>

<h2>Some Preparations</h2>
<p>
  There might be several ways to organize source code and templates of a ruby-on-rails application,
  so to have some sort of basis we will start with a standard CRUD controller generated by the rails
  scaffold generator.
</p>
<p>
  Then we extract a picture partial out of the <tt>index</tt> template so that we could reuse it in our
  scripts. The <tt>index</tt> and <tt>_picture</tt> templates should look something like this
</p>
<code>
// index.html.erb
<h1>Listing pictures</h1>

<div id="pictures">
  &lt;%= render @pictures %>
</div>


// _picture.html.erb
&lt;% div_for picture do %>
  &lt;%= link_to image_tag(picture.image.url(:thmb)), picture.image.url(:medium),
    :title => picture.title, :rel => "lightbox[roadtrip]" %>
    
  &lt;%= link_to 'Edit', edit_picture_path(picture) %>
  &lt;%= link_to 'Destroy', picture, :confirm => 'Are you sure?', :method => :delete %>
&lt;% end %>
</code>

<p>
  We also extract a <tt>_form</tt> partial out of the <tt>new</tt> and <tt>edit</tt> templates, like this
</p>
<code>
// new.html.erb
<h1>New picture</h1>

&lt;%= render 'form' %>


// edit.html.erb
<h1>Edit picture</h1>

&lt;%= render 'form' %>


// _form.html.erb
&lt;% form_for(@picture, :html => {:multipart => :true}) do |f| %>
  &lt;%= f.error_messages %>
  // .....
  <p class="buttons">
    &lt;%= f.submit  f.object.new_record? ? 'Create' : 'Update' %>
    &lt;%= image_tag 'spinner.gif', :class => :spinner %>
  </p>
&lt;% end %>
</code>

<p>
  Okay, enough with the preparations lets get to the fun part
</p>


<h2>Files Uploading</h2>
<p>
  As it is an ajaxed maintenance I would like to have a hidden form for an instant pictures uploading.
  For this purpose we simple create a dummy <tt>@picture</tt> variable and render the <tt>_form</tt> partial
  right under the <tt>'New picture'</tt> link at the <tt>index</tt> template, and then add the
  <tt>onclick</tt> attribute to the link, which will toggle the form
</p>
<code>
// index.html.erb
// .....
&lt;%= link_to 'New picture', new_picture_path,
  :onclick => "$('new-form-container').toggle('slide'); return false;" %>

<div id="new-form-container">
  &lt;% @picture = Picture.new %>
  &lt;%= render 'form' %>
</div>
</code>
<p>
  This way, when the user clicks the link he will see the form slides in and out, but he will also
  be able to call the link context menu, open the address in new tab|window and have access to the
  basic maintenance as usual.
</p>
<p>
  Then below those elements we will need a piece of JavaScript code that will convert the form
  into a remote form. Conventionally the new picture form in ruby-on-rails will have the 
  <tt>new_picture</tt> id. So we use it.
</p>
<code>
function remotize_form(id) {
  var form = $(id);
  if (form) {
    form.remotize().enable().action += '.js';
  }
};
remotize_form('new_picture');
</code>
<p>
  We created a separated function so that we could reuse it to activate another forms later. And
  as all the altering methods in RightJS return back a reference to an object, we can do fancy calls
  like <tt>form.remotize().enable().action</tt>.
</p>
<p>
  Then as you see we altered the form <tt>action</tt> property so that we have different format for
  ajaxed requests, which we can handle in the rails application controller by adding another format
  handler like that
</p>
<code>
// PicturesController
def create
  // ....
  respond_to do |format|
    // ....
    format.js
  end
end
</code>
<p>
  And finally we create a simple <tt>create.js.erb</tt> file that will render the response of our calls
  and generate some JavaScript code that will trigger changes on our page.
</p>
<p>
  It checks if the picture was saved, then generates the new picture thumbnail block and finally rerenders
  the picture form. We need this form update anyway, if there were problems then the form will contain
  explanations and marks for the issues, if the upload was successful then we will need a new clean form again.
</p>
<code>
&lt;% unless @picture.new_record? %>
  insert_picture("&lt;%= escape_javascript(render(@picture)) %>");
  
  &lt;% @picture = Picture.new # resetting the instance to have a clean form %>
&lt;% end %>

replace_form('new_form', "&lt;%= escape_javascript(render('form')) %>");
</code>
<p>
  As you see we have defined two new functions <tt>insert_picture</tt> and <tt>replace_form</tt>,
  we could put all the logic right in the file and make all the page changes from the template,
  but it is always better in those cases to keep all the logic in one place and work through
  some proxy interface. This way it will be easier to maintain the code later. You might think
  about it like the basic principle of OOP incapsulating applied to the templates.
</p>
<p>
  So we define those two functions at the <tt>index</tt> template right below the <tt>remotize_form</tt>
  function.
</p>
<code>
function insert_picture(source) {
  $('pictures').insert(source);
  Lightbox.rescan();
};

function replace_form(id, source) {
  $(id).replace(source);
  remotize_form(id);
};
</code>
<p>
  We used the <tt>Lightbox.rescan()</tt> call to make the Lightbox widget to catch up the new image.
</p>
<p>
  Okay. This looks simple enough. Three short simple functions and we are in business.
</p>

<h2>Unfortunately it wont work</h2>
<p>
  The problem is that when you have a file field on your form and you create a remote submit,
  in reality you submit the form through a hidden <tt>iframe</tt> element. And then when you load
  a javascript response in an iframe element, the smart IE browsers will nicely offer you to download
  the response on your disk.
</p>
<p>
  The only response that an IFrame can process is a <tt>text/html</tt> one. And then if we even
  override the response type in our rails application it still won't work because the IFrame has
  it's own context and document.
</p>
<p>
  Solving those things might be tricky and bring quite a mess in your code, but luckily there is
  a simple way out.
</p>
<p>
  All you need is to create another simple html layout that will wrap the iframed uploads, like this
</p>
<code>
// app/view/layouts/iframed.html.erb
<html>
  <head>
    <script type="text/javascript">
    // <![CDATA[
      with (self.parent) {
        &lt;%= yield %>
      }
    // ]]>
    </script>
  </head>
</html>
</code>
<p>
  And then slightly change the <tt>format.js</tt> call in your controller, like this
</p>
<code>
def create
  ....
  format.js { render :layout => 'iframed', :content_type => 'text/html' }
end
</code>
<p>
  The idea as you understand is simple. We just wrap the script in an html response where
  it will get evaluated in the context of the parent window, like if it was an usual Xhr
  request and usual JavaScript response.
</p>
<p>
  The reason of doing it this way is simple. You separate the things which lets you reuse
  the layout in another remote uploads handling and then you keep your javascript response
  template consistent and simple, like if you really worked with XHR requests.
</p>
<p>
  Okay this was the whole trick. After that the uploads will work nicely.
</p>

<h2>Summary</h2>
<p>
  That might looked like a bit long explanation, but if you take a look at the whole thing
  you will see how nicely we reused all the original templates and handled all the process
  in just a few short JavaScript functions.
</p>
<p>
  We also didn't wreak the original functionality and now our user has an option, use
  the ajaxed interface or the basic new picture form on a separated page.
</p>

<h2>The Further Steps</h2>
<p>
  If you download the source code out of the github repository you'll find the complete
  application where more things solved like the pictures ajaxed editing and deleting and so one.
  There are also some visual effects applied to the maintenance.
</p>
<p>
  But the principles remain to be the same as I've just described, so there no need to repeat
  them in here. Just take a look at the code, there are just a few more simple functions, I'm sure
  you will understand what they do.
</p>
