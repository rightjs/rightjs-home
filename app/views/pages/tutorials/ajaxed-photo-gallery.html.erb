<h1>Ajaxed Photo Gallery</h1><% @title_text = "Tutotirals: Ajaxed Photo Gallery" %>

<p>
  In this tutorial we will take a look at things in complex and develop some
  ajaxed web photo gallery using RightJS and the Ruby On Rails framework.
</p>
<p>
  We will use Ruby On Rails as it is current industry standard in its own way,
  but most of the things are applicable to any other framework and meant to display
  basic technics when you do things with RightJS, like files uploading, page alterations, etc.
</p>

<h2>The Source Code Download</h2>
<p>
  You can grab the whole project at this repository at the github service
</p>
<p>
  <a href="http://github.com/MadRabbit/right-gallery" target="_blank">http://github.com/MadRabbit/right-gallery</a>
</p>
<p>
  <tt>git clone git://github.com/MadRabbit/right-gallery.git</tt>
</p>
<p>
  It's just a simple ruby-on-rails application, I'm sure you can find out how to fire it up and play with the thing.
</p>

<h2>The Strategy</h2>
<p>
  There are many ways to implement the feature, some of them more simpler than others, but we will use
  a kind of mixed approach. We will start with a standard working CRUD controller and basic functionality
  and create a JavaScript wrap up over it.
</p>
<p>
  The target is to implement a transparent ajax functionality the way that the original one was still
  available, so that the user could always hit the right mouse button and choose to open the links in 
  new tab or window or give a link for another user to edit or create new pictures in the gallery.
</p>
<p>
  We also aim to make a great deal of the original templates re usage and javascript code simplicity.
</p>

<h2>Some Preparations</h2>
<p>
  There might be several ways to organize source code and templates of a ruby-on-rails application,
  so to have some sort of basis we will start with a standard CRUD controller generated by the rails
  scaffold generator.
</p>
<p>
  Then we extract a picture partial out of the <tt>index</tt> template so that we could reuse it in our
  scripts. The <tt>index</tt> and <tt>_picture</tt> templates should look something like this
</p>
<code>
// index.html.erb
<h1>Listing pictures</h1>

<div id="pictures">
  &lt;%= render @pictures %>
</div>


// _picture.html.erb
&lt;% div_for picture do %>
  &lt;%= link_to image_tag(picture.image.url(:thmb)),
    picture.image.url(:medium), :title => picture.title %>
    
  &lt;%= link_to 'Edit', edit_picture_path(picture) %>
  &lt;%= link_to 'Destroy', picture, :confirm => 'Are you sure?', :method => :delete %>
&lt;% end %>
</code>

<p>
  We also extract a <tt>_form</tt> partial out of the <tt>new</tt> and <tt>edit</tt> templates, like this
</p>
<code>
// new.html.erb
<h1>New picture</h1>

&lt;%= render 'form' %>


// edit.html.erb
<h1>Edit picture</h1>

&lt;%= render 'form' %>


// _form.html.erb
&lt;% form_for(@picture, :html => {:multipart => :true}) do |f| %>
  &lt;%= f.error_messages %>
  // .....
  <p class="buttons">
    &lt;%= f.submit  f.object.new_record? ? 'Create' : 'Update' %>
    &lt;%= image_tag 'spinner.gif', :class => :spinner %>
  </p>
&lt;% end %>
</code>

<p>
  Okay, enough with the preparations lets get to the fun part
</p>

<h2>Pictures Deleting</h2>
<p>
  Lets start with something simple, for example images deleting.
</p>
<p>
  What we will do we will hijack the <tt>delete</tt> links and assign our own
  <tt>onclick</tt> handler. This way if we screwed up with something, the original
  functionality will back us up.
</p>
<p>
  For the beginning we need to add css class <tt>delete</tt> to the delete links
  in the <tt>_picture</tt> partial, so we could find and process them.
</p>
<code>
// _picture.html.erb
&lt; div_for picture do %>
  ......
  &lt;%= link_to 'Destroy', picture, :class => :delete //...
&lt;% end %>
</code>
<p>
  Adding such classes is a good practice anyway, it will let you paint those links
  with some different color later, maybe add some fancy icon, etc.
</p>
<p>
  Okay now lets highjack the event
</p>
<code>
function hijack_links() {
  $$('#pictures a.delete').each(function(link) {
    link.onclick = function(event) {
      event.stop();
      
      if (confirm("Are you sure?")) {
        Xhr.load(this.href+".js", { method: 'delete' });
      }
    };
  });
}
hijack_links();
</code>
<p>
  We use a function so that we could call this code again when we upload new pictures via ajax.
</p>
<p>
  Then we need to add the <tt>.js</tt> format handler to the <tt>destroy</tt> method
  in our Rails controller.
</p>
<code>
def destroy
  .....
  respond_to do |format|
    ....
    format.js
  end
end
</code>
<p>
  This will receive our ajax calls and render some piece of javascript that will remove our image.
  So we need some template called <tt>destroy.js.erb</tt>
</p>
<code>
// destroy.js.erb
remove_picture(&lt;%= @picture.id %>);


// index.html.erb
function remove_picture(id) {
  $('picture_'+id).remove();
}
</code>
<p>
  We could just write something like <tt>$('picture_&lt;%= @picture.id %>').remove()</tt> in the template
  but it's always better to keep all the functionality in one place and work through some sort
  of an interface. It will let you grow a simple library and then refactor and improve it separately
  without touching any other template.
</p>
<p>
  Okay, let's move to the next part
</p>

<h2>Files Uploading</h2>
<p>
  As it is an ajaxed maintenance I would like to have a hidden form for an instant pictures uploading.
  For this purpose we simple create a dummy <tt>@picture</tt> variable and render the <tt>_form</tt> partial
  right under the <tt>'New picture'</tt> link at the <tt>index</tt> template, and then add the
  <tt>onclick</tt> attribute to the link, which will toggle the form
</p>
<code>
// index.html.erb
// .....
&lt;%= link_to 'New picture', new_picture_path,
  :onclick => "$('new-form-container').toggle('slide'); return false;" %>

<div id="new-form-container">
  &lt;% @picture = Picture.new %>
  &lt;%= render 'form' %>
</div>
</code>
<p>
  This way, when the user clicks the link he will see the form slides in and out, but he will also
  be able to call the link context menu, open the address in new tab|window and have access to the
  basic maintenance as usual.
</p>
<p>
  Then below those elements we will need a piece of JavaScript code that will convert the form
  into a remote form. Conventionally the new picture form in ruby-on-rails will have the 
  <tt>new_picture</tt> id. So we use it.
</p>
<code>
function remotize_form(id) {
  $(id).remotize().enable().action += '.js';
};
remotize_form('new_picture');
</code>
<p>
  We created a separated function so that we could reuse it to activate another forms later. And
  as all the altering methods in RightJS return back a reference to an object, we can do fancy calls
  like <tt>form.remotize().enable().action</tt>.
</p>
<p>
  Then as you see we altered the form <tt>action</tt> property so that we have different format for
  ajaxed requests, which we can handle in the rails application controller by adding another format
  handler like that
</p>
<code>
// PicturesController
def create
  // ....
  respond_to do |format|
    // ....
    format.js
  end
end
</code>
<p>
  And finally we create a simple <tt>create.js.erb</tt> file that will render the response of our calls
  and generate some JavaScript code that will trigger changes on our page.
</p>
<p>
  It checks if the picture was saved, then generates the new picture thumbnail block and finally rerenders
  the picture form. We need this form update anyway, if there were problems then the form will contain
  explanations and marks for the issues, if the upload was successful then we will need a new clean form again.
</p>
<code>
&lt;% unless @picture.new_record? %>
  insert_picture("&lt;%= escape_javascript(render(@picture)) %>");
  
  &lt;% @picture = Picture.new # resetting the instance to have a clean form %>
&lt;% end %>

replace_form('new_form', "&lt;%= escape_javascript(render('form')) %>");
</code>
<p>
  Once again we defined two proxy functions, one will insert the new image on the page, the other
  updates the form. Implementation is really simple.
</p>
<code>
function insert_picture(source) {
  $('pictures').insert(source);
  hijack_links();  // find and process the new links
};

function replace_form(id, source) {
  $(id).replace(source);
  remotize_form(id);
};
</code>
<p>
  Okay. This looks simple enough. Two short simple functions and we are in business.
</p>

<h2>Unfortunately it wont work</h2>
<p>
  The problem is that when you have a file field on your form and you create a remote submit,
  in reality you submit the form through a hidden <tt>iframe</tt> element. And then when you load
  a javascript response in an iframe element, the smart IE browsers will nicely offer you to download
  the response on your disk.
</p>
<p>
  The only response that an IFrame can process is a <tt>text/html</tt> one. And then if we even
  override the response type in our rails application it still won't work because the IFrame has
  it's own context and document.
</p>
<p>
  Solving those things might be tricky and bring quite a mess in your code, but luckily there is
  a simple way out.
</p>
<p>
  All you need is to create another simple html layout that will wrap the iframed uploads, like this
</p>
<code>
// app/view/layouts/iframed.html.erb
<html>
  <head>
    <script type="text/javascript">
    // <![CDATA[
      with (self.parent) {
        &lt;%= yield %>
      }
    // ]]>
    </script>
  </head>
</html>
</code>
<p>
  And then slightly change the <tt>format.js</tt> call in your controller, like this
</p>
<code>
def create
  ....
  format.js { render :layout => 'iframed', :content_type => 'text/html' }
end
</code>
<p>
  The idea as you understand is simple. We just wrap the script in an html response where
  it will get evaluated in the context of the parent window, like if it was an usual Xhr
  request and usual JavaScript response.
</p>
<p>
  The reason of doing it this way is simple. You separate the things which lets you reuse
  the layout in another remote uploads handling and then you keep your javascript response
  template consistent and simple, like if you really worked with XHR requests.
</p>
<p>
  Okay this was the whole trick. After that the uploads will work nicely.
</p>

<h2>Pictures Editing</h2>

<p>
  Lets finish up with the thing by adding an ajax pictures editing functionality. Now
  when we know how the things work there won't be any problem.
</p>
<p>
  First we need to add the <tt>edit</tt> css class to our edit links so we could hijack
  clicks, exactly how we did it with the pictures deleting feature.
</p>
<code>
// _picture.html.erb
....
  link_to 'Edit', edit_picture_path(picture), :class => 'edit', //...


// index.html.erb
function hijack_links() {
  // delete links processing in here
  
  $$("#pictures a.edit").each(function(link) {
    link.onclick = function(event) {
      event.stop();
      Xhr.load(this.href + ".js");
    }
  });
}
</code>
<p>
  We don't need to touch our controller for generating a GET response for the
  <tt>edit</tt> action, we just create the <tt>edit.js.erb</tt> template and
  add another function that will handle the things on the page
</p>
<code>
// edit.js.erb
show_edit_form(&lt;%= @picture.id %>, "&lt;%= escape_javascript(render("form")) %>");


// index.html.erb
function show_edit_form(id, source) {
  $$('form.edit_picture').each('remove');
  
  remotize_form(
    $('picture_'+id).insert(source)
      .first('form.edit_picture').show('fade')
  );
}
</code>
<p>
  The script is simple. It just removes any possibly hanging around old popups.
  Then we add the source to the picture block, find our form, make it nicely appear
  and finally make it remote.
</p>
<p>
  That's all we need to load and show the remote form. Now lets catch the form 
  submits, just like we did in the new pictures uploading. We define the <tt>.js</tt>
  response handler in the <tt>update</tt> method in our controller
</p>
<code>
def update
  ....
  respond_to do |format|
    ....
    format.js   { render :layout => 'iframed', :content_type => 'text/html' }
  end
end
</code>
<p>
  Then add some simple template called <tt>update.js.erb</tt> and a javascript function
  called <tt>update_picture</tt>that will handle the things.
</p>
<code>
// update.js.erb
&lt;% if @picture.valid? %>
  update_picture(&lt;%= @picture.id %>, "&lt;%= escape_javascript(render(@picture))%>");
&lt;% else %>
  replace_form('edit_picture_&lt;%= @picture.id%>', "&lt;%= escape_javascript(render('form')) %>");
&lt;% end -%>


// index.html.erb
function update_picture(id, source) {
  $('picture_'+id).replace(source);
  
  hijack_links();
};
</code>
<p>
  This is pretty much all about it.
</p>

<h2>Summary</h2>
<p>
  That might looked like a bit long explanation, but if you take a look at the whole thing
  you will see how nicely we reused all the original templates and handled all the process
  in just a few short and simple JavaScript functions.
</p>
<p>
  We also didn't wreak the original functionality and now our user has an option, use
  the ajax interface or the basic features on separated pages.
</p>

<h2>The Further Steps</h2>
<p>
  If you download the source code out of the github repository you'll find the complete
  application where more things solved like the the Lightbox feature usage, spinners handling,
  some more visual effects processing etc.
</p>
