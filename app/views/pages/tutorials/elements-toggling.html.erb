<h1>Elements Visual State Toggling</h1><% @title_text = "Tutorial: Elements Visual State Toggling" %>
<% controller.instance_eval{ @unit = Unit.find_by_name('Element')}%>

<p>
  There are several methods in RightJS that supposed to help you to switch dom-elements visual
  state. Most of them are standard but there some additional features and details
  that might be useful to know.
</p>

<h2>Standard Visibility Toggling</h2>
<p>
  RightJS has all the standard methods like {Element#hide}, {Element#show}, {Element#toggle}
  to switch the dom-elements visibility status on and off. Additionally there is the {Element#radio}
  method that might be seen in some other frameworks. This method shows the element and hides
  all the siblings.
</p>
<p>
  There are two important things you should know about those methods.
</p>
<p>
  First of all those methods preserve the element style <tt>display</tt> property. So that if
  you has changed an element style then hidden it and then shown again, the element will remain the
  original <tt>display</tt> value.
</p>
<code>
$(element).style.display = 'inline-block';

$(element).hide();
$(element).show();

$(element).style.display; // -> 'inline-block'
</code>
<p>
  Secondly as all the methods in RightJS that change an object, those methods return reference
  to the element back, so that you could write nice and readable phrases in your code.
  Like that:
</p>
<code>
$(element).show().update('with text').highlight();
</code>

<h2>CSS Classes Toggling</h2>
<p>
  There are list of standard methods to manage the css-classes presence on dom-elements
  {Element#addClass}, {Element#removeClass}, {Element#hasClass}, {Element#toggleClass},
  {Element#radioClass}.
</p>
<p>
  The usage of them is pretty straight forward:
</p>
<code>
/**
 * <ul id="some-menu">
 *  <li>one</li>
 *  <li>two</li>
 *  <li>three</li>
 * </ul>
 */
 
$('some-menu').select('li').each('onClick', 'radioClass', 'marked');
</code>

<h2>Visibility Toggling With Visual Effects</h2>
<p>
  Some visual effects like {Fx.Slide} and {Fx.Fade} are bidirectional. Which means that
  they can work in both directions to show and to hide an element.
</p>
<p>
  By default they will automatically determine an element current state and work towards
  the opposite one. Which means that it is an fx equivalent of the {Element#toggle} method.
</p>
<code>
$(element).style.display = 'none';

$(element).fade(); // -> shows
$(element).fade(); // -> hides
</code>
<p>
  If you need an effect to work in some direction specifically you can define it manually,
  like that:
</p>
<code>
$(element).slide('out'); // hides despite on the element state
$(element).slide('in');
</code>


<h2>Mixed Approach</h2>
<p>
  The visual effects library in RightJS is not a required module and can be switched off
  by the <%= link_to 'custom build', builds_path %> process.
</p>
<p>
  In case when you write some sort of a plugin or widget, which supposed to work in both
  cases whenever the Fx module is included or not, you might find the mixed approach
  useful.
</p>
<p>
  The idea is simple: you use the standard {Element#hide}, {Element#show}, etc. methods
  and pass the desired visual effect name and options as the arguments to the method,
  like this:
</p>
<code>
$(element).hide('fade');
$(element).show('slide', {direction: 'right'});
</code>
<p>
  In this case, if there is the Fx library then the element will be processed with the
  specified visual effect and if the Fx library is not available, then the element will
  get just hidden/shown immediately. 
</p>
