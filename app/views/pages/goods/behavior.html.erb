<h1>Behaviors Module</h1><% @title_text = 'Goods: Behaviors Module' %>

<p>
  The behaviors module provides you an ability to define an elements behavior group (by a css-rule)
  and then it will automatically watch any changes on the web-page and update matching elements.
</p>

<%= anchors_index %>


<%= chapter "Simple Example", :simple %>
<p>
  The usage is really simple, you just define a css-rule and events that you want to handle
</p>
<code>
"#todo-list div.item".behave('click', function() {....});
</code>
<p>
  After that the script will update all the matching elements on the page so they handled
  the <tt>'click'</tt> event with the function and then whenever you add new items onto the
  todo-list element, it will automatically assign the event handling to them.
</p>
<p>
  If you started the behavior at the page loading time, the script will scan through the page
  once more when it's loaded.
</p>

<%= chapter "RightJS Features Are Also Available", :rightjs %>
<p>
  The <tt>'behave'</tt> method supports all the same argument types as the {Observer#observe} method,
  including the <a href="/tutorials/call-by-name">call by name</a> feature, custom events, etc.
  There are no limitations.
</p>
<code>
// a hash of events
"#todo-list div.item".behave({
  click:     function1,
  mouseover: function2,
  mouseout:  function3
});

// or with a list
"#todo-list div.item".behave('click', [function1, function2, ..]);

// or by name
"#todo-list div.item".behave('click', 'radioClass', 'selected');
</code>


<%= chapter "Stopping Behavior", :stopping %>
<p>
  If you need to cancel some behavior, just call the <tt>'stopBehave'</tt> method and it will remove all
  the registered callbacks out of processed elements and will stop watching the page updates.
</p>
<code>
"#todo-list div.item".behave('click', function() {});

"#todo-list div.item".stopBehave();
</code>


<%= chapter "Manual Triggering", :manual %>
<p>
  By default the script will watch when you change the page by using the RightJS {Element} methods, like
  {Element#insert}, {Element#update}, etc. But if you did changed your page manually by say altering an
  <tt>innerHTML</tt> attribute, you can manually trigger the behaviors update by calling the 
  <tt>{Behavior.refresh}</tt> method.
</p>
<code>
"#todo-list div.item".behave('click', 'toggleClass', 'selected');

$('todo-list').innserHTML = "...";

// this will go through all the registered behaviors and rescan the page
Behavior.refresh();
</code>

<%= chapter "Tough Bastards Way", :tough %>
<p>
  In case of more complex development you might want some more serious way of your behaviors
  library organization; with classes, objects and so one. We have 'em too. 
</p>
<p>
  There is a class called <tt>Behavior</tt>, which has the following simple methods:
  <table>
    <tr><th>Name</th>    <th>Description</th></tr>
    <tr><td>start</td>   <td>makes the behavior active</td></tr>
    <tr><td>stop</td>    <td>deactivates the behavior</td></tr>
    <tr><td>active</td>  <td>checks if the behavior is active</td></tr>
    <tr><td>refresh</td> <td>rescans the page for elements matching to this behave css-rule</td></tr>
  </table>
</p>
<p>
  The usage is pretty straight forward:
</p>
<code>
new Behave("#todo-list div.item", "click", function() {...});
new Behave("#todo-list div.item", "click", [func1, func2, func3]);
new Behave("#todo-list div.item", "click", "radioClass", "selected");

var behave = new Behave("css-rule", {event: function() {}});
behave.start().stop().start().refresh();
</code>